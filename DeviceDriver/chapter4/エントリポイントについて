アプリケーションのmain関数の呼び出しフローについて

main関数は、glibcというcライブラリの中から呼び出されており、returnで戻る場所もここである。

バイナリを実行すると最初に親プロセスがshell(bash)などになる。
そして、shellがfork+execを使って新しいプロセスを生成して、起動をかける。
「execve」を呼び出す。
システムコールを発行するとこの時点で、制御がユーザー空間からカーネル空間に移動する
カーネル内では、sys_execve()でローダを起動する。

ELFインタプリタの実行ファイルは「/lib/ld-linux.so.2」である。実行バイナリファイルはlibc(Cライブラリ)を動的リンクしている。インタプリタがlibcをロードしている。その後スタートアップルーチン(_startラベル)に制御が移動する。ここは、glibcの一部の中にスタートアップルーチンの関数がある。それが終わったあと、__libc_start_mainが呼び出されて、そこからmain()が呼ばれる。


一方のドライバエントリポイントは、最低2つ
・insmodやmodprobeから呼ばれる初期化関数
・rmmodから呼ばれる終了関数

これら以外にも
・システムコール
・割り込みルーチン
・タイマルーチン

システムコールはアプリとカーネル間で情報のやりとりをするためのインターフェイス
アプリがカーネルの機能の呼び出すことができる。

ドライバにおけるコンテキストとは、エントリポイントから始まって、末端の関数までの一連の処理の流れ

コンテキストは2つ
・プロセスコンテキスト
・割り込みコンテキスト

プロセスコンテキストは、ユーザ空間のアプリ(プロセス)から始まるコンテキストのこと

割り込みコンテキストはハードから割り込まれ始まったコンテキスト