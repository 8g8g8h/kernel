コンテキストはエントリポイントから始まって、末端の関数までの一連の処理の流れ

プロセスコンテキストは、ユーザー空間のアプリから始まるコンテキスト(プログラムなども含まれる)

プロセスコンテキストは、ユーザーコンテキストやスレッドコンテキストとも呼ばれる

これら以外にも割り込みコンテキストやカーネルコンテキスト(しかし、新しいコンテキストでもない)もある。

プロセスコンテキストは、スリープやプリエンプティブができる。

スリープとは、何らかの事象を待つためにプロセスが休眠状態になることができる。
スリープしている間は、cpuは他の作業を行うことができる。
これは、プロセスコンテキストでスリープができる、すなわちスリープ系のカーネル関数が使用できる。

プリエンプティブとは、cpuのスケジューリング用語で、OSがタスクをするためのcpu割当時間を強制的に切り替えることができる。マルチタスクとも言う。

プロセスコンテキストがカーネル空間での処理に移動した場合、ここでは、プリエンプティブではなくなる。(設定すれば、プリエンプティブにもできるが基本はしない)
つまり、割り込みが入らない限り、実行中の処理が変わることはない。

一方、割り込みコンテキストは、スリープやプリエンプティブもできない

つまり、使用するカーネル関数がスリープしないことでもある

ーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーー
ドライバのアラインメントについて

ドライバは、ハードウェアを制御するのが仕事。そこにはメモリ制御も含まれる。
メモリの制限事項のことをメモリアラインメントという。

ページサイズなどの設定などをして、必要な境界合わせを行う

境界合わせとは、メモリポインタがページの境界になっていないといけない。その境界を合わせること。やり方は以下の通りである。

・必要なページ数より一つ多めにメモリを確保する
・new pointer=(memory pointer+PAGE_SIZE-1)&~(PAGE_SIZE-1)

イメージとしては、1ページが必要な場合は、2つ分のページサイズを確保する。
次に、今のメモリから下方向で一番近いアドレスをページ境界のメモリポインタにする

メモリ関連として、構造体のメンバについても考えられます

ここで構造体のフォーマットを決めておく必要がある。なぜなら、メモリアクセスがマルチバイト単位でないと、例外でOSが落ちるからである。
実際には、構造体のパックと言うものが使われており、これによりメモリアクセスがしやすくなる。(奇数でメモリが始まってしまうと、分割されてしまいメモリアクセスの効率が低下する)

--------------------------------------------------------------------
リンクドリスト

ドライバ開発でじゃ制御対象のハードに対するリクエストデータを管理するために使われるアルゴリズ

・スタック型リンクドリストの特徴

headを一つ持つ
リストは単方向のみ
リストへの追加はリストの先頭へ挿入されるため、リストの並びが逆になる。lifo型である。イメージはスタック

リストのHEAD構造体は以下のようになっている。

struct sample_data{
	spinlock_t lock;
	struct file *file;
	struct list_head list;
	wait_queue_head_t wait;
};

struct sample_data head;

このようにしてリストを作る。