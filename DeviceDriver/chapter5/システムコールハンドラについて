デバイスドライバを動的に登録する方法

alloc_chrdev_region()でメジャー番号の動的確保
↓
cdev_init()でシステムコールハンドラを登録する
↓
cdev_add()でカーネルドライバを登録する

ーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーー
システムコールハンドラの登録

これは、file_operations構造体で設定する

システムコールハンドラが設定し終わったら、open()やread()などのシステムコールを発行できる

ーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーー
open()ハンドラについて

int open(struct inode *inode,struct file *file);


inodeとは、ファイルのうち、「名前」、「データ本体」以外のメタデータ(属 性、データを保持しているブロックへのポインタ) を保持するもの。

これはファイルの中に、もちろんデバイスファイルも含まれる

*inodeは構造体へのポインタであり、構造体は以下の2つから成り立つ

bdev_t i_rdev メジャ番号とマイナー番号
void *i_private ドライバプライベートポインタ

ドライバ内でマイナー番号を識別して、デバイスの制御を切り替えたい場合に参照する

ret=iminor(inode)

これでマイナー番号識別する

同様にiminorを用いることでメジャー番号を識別できる

i_privateは以下のように使う

・openハンドラでメモリを確保して、プライベートメンバへつなげる
・writeやreadなどのハンドええあでプライベートメンバを参照する
・closeハンドラで確保したメモリを解放する

file構造体

struct file_operations *f_op システムコールハンドラ
unsigned int f_flags open関数の第2引数
void *private_data ドライバプライベートポインタ

f_opは、ドライバのロード時に、メジャー番号を登録する
メジャー番号を登録する際に同時に、システムコールハンドラへのポインタも登録している。そのポインタを変える際に使われるものである。

ファイルをcloseするために、どのopenしたファイルを閉じるかを明確に決めないといけない。

そこで、openしたときに、inode構造体やfile構造体のドライバプライベートポインタを用いる

openハンドラの返り値はintで返す

sys_open
↓
do_sys_open
↓
do_filp_open
↓
open_namei
↓
nameidata_to_filp
↓
_dentry_open

の順番で開かれる

ドライバプライベートポインタ(inode->i_private)は、デバイスファイルそのものに関連付けた情報を紐づけたい場合に使用する

ーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーー
close()ハンドラ

int release (struct inode *inode,struct file *file);

openで確保したリソースをcloseで解放する

どれをcloseするかについては、inodeやfile構造体のドライバプライベートポインタを利用する

closeする流れは以下に示す

sys_close
↓
filp_close
↓
filp->f_op->flush()
↓
fput()
↓
__fput()
↓
file->f_op->release


・inode構造体=1つ
・file構造体=デバイスファイルがオープンされた回数分開く

ドライバがopenシステムコールを一意に識別するにはfile構造体のドライバプライベートポインタを使用する